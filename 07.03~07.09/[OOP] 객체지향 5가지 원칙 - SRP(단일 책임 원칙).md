##1. 단일 책임 원칙 - SRP(Single Responsibility Principle)

---

SOLID 원칙 중 첫 번째인 **SRP(Single Responsibility Principle, 단일 책임 원칙)**은 소프트웨어 설계에 중요한 개념 중 하나입니다.  
**'SRP'**는 _"한 클래스는 하나의 책임만 가져야 한다"_라고 정의합니다.   
_"하나의 책임"_ 이 말에서 **'책임'**이란 하나의 **'기능'**이라고 보면 쉽게 이해할 수 있습니다. (책임 = 기능)

### 1 - 1. SRP 실생활 예시

실생활에 예시를 들어보면, 한 식당에서 한 명의 직원 역할이 **요리사, 웨이터, 매니저** 등 **다수의 역할**을 맡은 직원이 있습니다.

[##_Image|kage@bos1z3/btsIqTDNMtH/Z2WeHQFDKAq4YZXlGlzgOk/img.png|CDM|1.3|{"originWidth":611,"originHeight":393,"style":"alignCenter","width":456,"height":293,"caption":"3가지 역할을 맡은 직원"}_##]

만약, **직원(웨이터)** 입장에서 음식을 제공하던 중 실수로 음식을 손님에게 떨어트렸습니다.  
그러면 각 역할마다 다음과 같은 임무를 수행 해야합니다.

-   **직원(웨이터)** : 흘린 음식과 접시를 치워야 한다
-   **직원(매니저)** : 손님분께 사과를 드려야 한다
-   **직원(요리사)** : 음식을 다시 재조 해야 한다

이렇게 어떤 문제가 발생하면, 모든 책임은 **3가지의 역할**을 맡은 **한 명의 직원**에게 있습니다. 💦

또한, 다른 상황 예시는 **직원(요리사)이** 음식 홀서빙이 늦어져서 **직원(웨이터)으로** **역할을 변경**했습니다.  
그러다 갑자기 주문의 양이 늘어서 **직원(웨이터)은** 다시 **직원(요리사)으로** **역할을 변경**했습니다.

-   직원(요리사) -> 직원(웨이터) -> 직원(요리사) -> 직원(매니저) -...

이렇게 3가지 역할을 한 직원이 맡게 된다면, 옷을 갈아입는 시간, 상황 파악 시간 등의 **연쇄작용**이 일어나 **매우 비효율적**이고 **혼란**스러울 수 있습니다. 😵‍💫

> **연쇄작용이란? 🤔  
> **한 클래스 또는 모듈이 여러 책임을 가질 때 발생하는 일련의 문제들을 의미합니다. 

[##_Image|kage@bFX28x/btsIqTqhUUB/HLyPFWM728pUdKwt7DmVI1/img.png|CDM|1.3|{"originWidth":691,"originHeight":393,"style":"alignCenter","width":508,"height":289,"caption":"직원마다 역할 부여"}_##]

해결책은 위 자료와 같이 **_"한 직원은 하나의 역할만 부여한다"_**라는 법칙 적용해 업무에 용이하며, 효율적이게 일을 처리할 수 있도록 개선해야 합니다. 이렇게 실생활 예시처럼 객체지향에서도 **_"한 클래스는 하나의 책임만 가져야 한다"_**라는 SRP 원칙을 지향합니다.

### 1 - 2. SRP 코드 적용 예시

실생활 예시로 이해한 지식을 바탕으로 코드로 만나보도록 하겠습니다.  
아래 코드는 사용자를 관리하는 **추가/삭제 기능**과 **로그 기록**을 남기는 **기능**이 담긴 클래스입니다.

```
public class User {
    // 사용자 추가
    public void addUser(String userName) {
        System.out.println("데이터 베이스에 추가되었습니다. 해당 사용자 이름:" + userName);
        logAction(userName);
    }

    // 사용자 삭제
    public void deleteUser(String userName) {
        System.out.println("데이터 베이스에서 삭제되었습니다. 해당 사용자 이름:" + userName);
        logAction(userName);
    }

    // 로그 파일 기록
    private void logAction(String message) {
        System.out.println("[유저] log : " + message);
    }
}
```

```
public class UserMain {
    public static void main(String[] args) {
        User user = new User();

        user.addUser("홍길동");
        user.deleteUser("홍길동");
    }
}
```

실행을 하게 된다면, 아래 사진과 같은 결과가 나옵니다.

[##_Image|kage@AgQgR/btsIqwhPSoJ/mfRPOtk93ndzbpRYf0ol30/img.png|CDM|1.3|{"originWidth":904,"originHeight":230,"style":"alignCenter","width":353,"height":90,"caption":"출력 결과"}_##]

문득 보면 _"뭐가 이상한가? 기능을 정의하고 출력하는 거밖에 모르겠는데?"_라는 생각을 할 수 있습니다. 하지만! 위 코드는 **'****SRP 원칙'을 위배**한 코드입니다. 

'User' 클래스 안에는 3가지 기능이 담겨 있습니다. **'사용자 추가', '사용자 삭제', '로그 기록'** 정의되어 있는 클래스입니다. 물론 사용자 추가와 삭제는 하나의 기능으로 묶어서 **'사용자 관리'라고** 정의할 수 있습니다.

만약, 한 직원이 로그를 보던 중 "\[유저\] log : 홍길동" 표시로 유저가 **추가/삭제** 중에서 어떻게 되었는지는 모르겠다는 피드백으로 오류 발생 지점을 이리저리 찾다가 발견해 다음과 같이 코드를 변경했습니다.

```
// 로그 파일 기록
private void logAction(String message) {
    System.out.println("[추가된 유저] log : " + message);
}
```

[##_Image|kage@cfQRMz/btsIrOaKZzd/UFLQUBWg1rOApXuum6eUIK/img.png|CDM|1.3|{"originWidth":902,"originHeight":222,"style":"alignCenter","width":487,"height":120,"caption":"출력 결과"}_##]

하지만, 의견을 수용해 코드를 수정하고 결과물을 보았더니, 추가된 유저는 알 수 있지만 삭제된 유저도 추가되었다는 로그 메시지로 남게 됩니다.

현재는 50줄도 안 되는 코드와 2개의 클래스로 만들어진 작은 시스템이지만, **실무**에서는 엄청 많은 클래스와 메서드 등으로 다음과 같은 **오류가 발생**하면, **큰 혼란**을 겪게 됩니다.

그럼 **'SRP 원칙'**에 따라 수정된 코드를 보도록 하겠습니다.

```
public class User {
    private Log log;

    public User(Log log) {
        this.log = log;
    }

    // 사용자 추가
    public void addUser(String userName) {
        System.out.println("데이터 베이스에 추가되었습니다. 해당 사용자 이름:" + userName);
        log.logAction("사용자 추가 " + userName);
    }

    // 사용자 삭제
    public void deleteUser(String userName) {
        System.out.println("데이터 베이스에서 삭제되었습니다. 해당 사용자 이름:" + userName);
        log.logAction("사용자 삭제 " + userName);
    }
}
```

```
public class Log {
    // 로그 파일 기록
    public void logAction(String message) {
        System.out.println("log : " + message);
    }
}
```

이렇게 'User' 클래스는 사용자 관리의 책임, 'Log' 클래스는 로그 출력의 책임만 지니게 됩니다. 이렇게 분리함으로써 각 클래스는 변경에 대한 **영향을 최소화**하면서도, 자신의 **책임에 집중**할 수 있게 됩니다. 이를 통해 코드의 **유지보수성과 확장성이 향상**됩니다.

만약, 앞선 오류가 발생했을 경우에도 빠르게 문제를 탐색해 문제를 어떤 방향으로 해결할지 결정할 수 있습니다. 🤔

## 2\. 'SRP 원칙'을 적용해 얻는 장점

---

-   **유지보수성** : 각 클래스가 단 하나의 기능을 담당해 코드 이해와 수정에 용이
-   **오류** : 책임이 명확히 구분되어 오류 발생률이 적고, 만약 오류가 발생해도 더욱 쉽게 식별해 수정
-   **테스트** **코드** : 단일 책임을 지닌 클래스는 단위 테스트가 간단하고 효과적
-   **확장성** **및** **재사용성** : 각 클래스의 독립성이 높아져 재사용에 용이, 시스템 확장 시 유연하게 대응
-   **결합도와** **응집도** : 클래스 간 의존성 감소와 내부적으로 긴밀하게 협력하여 높은 응집도와 낮은 결합도 구성

> **결합도, 응집도** **반비례  
> 결합도** : 모듈 간 의존성의 정도를 뜻합니다.  
> **응집도** : 모듈 내부의 구성 요소 간 연관성의 정도를 뜻합니다.좋은 시스템은 응집도가 높고, 결합도는 낮습니다. ⭐️

## 3\. 'SRP 원칙' 적용 주의점

---

**클래스와 메서드의 좋은 이름 짓기(작명)**

하나의 기능을 담당하는 책임을 가진 클래스와 기능을 수행하는 메서드의 이름을 설정할 때, 어떠한 기능을 담당하는지 **이름만 들어도** 알 수 있도록 **작명**하는 것이 좋습니다.

**모든 기능의 무차별 분리**

_"한 클래스는 하나의 책임만 가져야 한다"말을_ 기반으로 기능을 막 분리하게 되면 오히려 유지보수 하기 어려운 시스템이 되어 버립니다.  
항상 **응집도와 결합도를 고려**하며, 프로그램을 구성하는 것이 좋습니다.

ex ) SRP 적용 전 코드 예시에는 **'사용자 추가', '사용자 삭제', '로그 기록'** 3가지 기능이 한 클래스에 있었습니다. 

-   **사용자 관리** : 사용자 추가, 사용자 삭제
-   **로그** : 로그 기록

SRP를 적용해 3가지 모두를 분류하는 것이 아닌, 2가지 분류를 나눈 거 처럼 **응집도와 결합도를 고려**해 시스템을 구성해야 합니다.

## 4\. 정리 📚

---

**SRP(Single Responsibility Principle, 단일 책임 원칙)**는 소프트웨어 설계의 중요한 원칙 중 하나입니다.  
각 클래스나 모듈이 하나의 책임 또는 기능만을 가지도록 지향합니다. 이 원칙에 따르면, 한 클래스는 하나의 변경 이유만을 가져야 하며, 이는 그 클래스가 담당하는 기능이나 책임에 한정됩니다.

**'SPR'**를 적용하면 코드의 유지보수성과 이해도가 향상되며, 각 부분의 독립성이 증가해 오류 발생 가능성이 낮아지고, 시스템 전체적으로 안정성과 확장성이 증가하게 됩니다.

## 5\. 참고(Reference) 📖

---

 [💠 완벽하게 이해하는 SRP (단일 책임 원칙)

단일 책임 원칙 - SRP (Single Responsibility Principle) 단일 책임 원칙(SRP)는 객체는 단 하나의 책임만 가져야 한다는 원칙을 말한다. 여기서 '책임' 이라는 의미는 하나의 '기능 담당'으로 보면 된다. 즉,

inpa.tistory.com](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99)
